{"version":3,"sources":["angular-touch.js"],"names":[],"mappings":"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","file":"angular-touch-compiled.js","sourcesContent":["/**\n * @license AngularJS v1.2.26\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngTouch\n * @description\n *\n * # ngTouch\n *\n * The `ngTouch` module provides touch events and other helpers for touch-enabled devices.\n * The implementation is based on jQuery Mobile touch event handling\n * ([jquerymobile.com](http://jquerymobile.com/)).\n *\n *\n * See {@link ngTouch.$swipe `$swipe`} for usage.\n *\n * <div doc-module-components=\"ngTouch\"></div>\n *\n */\n\n// define ngTouch module\n/* global -ngTouch */\nvar ngTouch = angular.module('ngTouch', []);\n\n/* global ngTouch: false */\n\n    /**\n     * @ngdoc service\n     * @name $swipe\n     *\n     * @description\n     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\n     * behavior, to make implementing swipe-related directives more convenient.\n     *\n     * Requires the {@link ngTouch `ngTouch`} module to be installed.\n     *\n     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`, and by\n     * `ngCarousel` in a separate component.\n     *\n     * # Usage\n     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\n     * which is to be watched for swipes, and an object with four handler functions. See the\n     * documentation for `bind` below.\n     */\n\nngTouch.factory('$swipe', [function() {\n  // The total distance in any direction before we make the call on swipe vs. scroll.\n  var MOVE_BUFFER_RADIUS = 10;\n\n  function getCoordinates(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var e = (event.changedTouches && event.changedTouches[0]) ||\n        (event.originalEvent && event.originalEvent.changedTouches &&\n            event.originalEvent.changedTouches[0]) ||\n        touches[0].originalEvent || touches[0];\n\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $swipe#bind\n     *\n     * @description\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\n     * object containing event handlers.\n     *\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }`.\n     *\n     * `start` is called on either `mousedown` or `touchstart`. After this event, `$swipe` is\n     * watching for `touchmove` or `mousemove` events. These events are ignored until the total\n     * distance moved in either dimension exceeds a small threshold.\n     *\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\n     *   A `cancel` event is sent.\n     *\n     * `move` is called on `mousemove` and `touchmove` after the above logic has determined that\n     * a swipe is in progress.\n     *\n     * `end` is called when a swipe is successfully completed with a `touchend` or `mouseup`.\n     *\n     * `cancel` is called either on a `touchcancel` from the browser, or when we begin scrolling\n     * as described above.\n     *\n     */\n    bind: function(element, eventHandlers) {\n      // Absolute total movement, used to control swipe vs. scroll.\n      var totalX, totalY;\n      // Coordinates of the start position.\n      var startCoords;\n      // Last event's position.\n      var lastPos;\n      // Whether a swipe is active.\n      var active = false;\n\n      element.on('touchstart mousedown', function(event) {\n        startCoords = getCoordinates(event);\n        active = true;\n        totalX = 0;\n        totalY = 0;\n        lastPos = startCoords;\n        eventHandlers['start'] && eventHandlers['start'](startCoords, event);\n      });\n\n      element.on('touchcancel', function(event) {\n        active = false;\n        eventHandlers['cancel'] && eventHandlers['cancel'](event);\n      });\n\n      element.on('touchmove mousemove', function(event) {\n        if (!active) return;\n\n        // Android will send a touchcancel if it thinks we're starting to scroll.\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\n        // we either:\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\n        // - On totalY > totalX, we let the browser handle it as a scroll.\n\n        if (!startCoords) return;\n        var coords = getCoordinates(event);\n\n        totalX += Math.abs(coords.x - lastPos.x);\n        totalY += Math.abs(coords.y - lastPos.y);\n\n        lastPos = coords;\n\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\n          return;\n        }\n\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\n        if (totalY > totalX) {\n          // Allow native scrolling to take over.\n          active = false;\n          eventHandlers['cancel'] && eventHandlers['cancel'](event);\n          return;\n        } else {\n          // Prevent the browser from scrolling.\n          event.preventDefault();\n          eventHandlers['move'] && eventHandlers['move'](coords, event);\n        }\n      });\n\n      element.on('touchend mouseup', function(event) {\n        if (!active) return;\n        active = false;\n        eventHandlers['end'] && eventHandlers['end'](getCoordinates(event), event);\n      });\n    }\n  };\n}]);\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngClick\n *\n * @description\n * A more powerful replacement for the default ngClick designed to be used on touchscreen\n * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending\n * the click event. This version handles them immediately, and then prevents the\n * following click event from propagating.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * This directive can fall back to using an ordinary click event, and so works on desktop\n * browsers as well as mobile.\n *\n * This directive also sets the CSS class `ng-click-active` while the element is being held\n * down (by a mouse click or touch) so you can restyle the depressed element if you wish.\n *\n * @element ANY\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate\n * upon tap. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngClickExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n          Increment\n        </button>\n        count: {{ count }}\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngClickExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nngTouch.config(['$provide', function($provide) {\n  $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n    // drop the default ngClick directive\n    $delegate.shift();\n    return $delegate;\n  }]);\n}]);\n\nngTouch.directive('ngClick', ['$parse', '$timeout', '$rootElement',\n    function($parse, $timeout, $rootElement) {\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\n\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\n  var lastPreventedTime;\n  var touchCoordinates;\n  var lastLabelClickCoordinates;\n\n\n  // TAP EVENTS AND GHOST CLICKS\n  //\n  // Why tap events?\n  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're\n  // double-tapping, and then fire a click event.\n  //\n  // This delay sucks and makes mobile apps feel unresponsive.\n  // So we detect touchstart, touchmove, touchcancel and touchend ourselves and determine when\n  // the user has tapped on something.\n  //\n  // What happens when the browser then generates a click event?\n  // The browser, of course, also detects the tap and fires a click after a delay. This results in\n  // tapping/clicking twice. We do \"clickbusting\" to prevent it.\n  //\n  // How does it work?\n  // We attach global touchstart and click handlers, that run during the capture (early) phase.\n  // So the sequence for a tap is:\n  // - global touchstart: Sets an \"allowable region\" at the point touched.\n  // - element's touchstart: Starts a touch\n  // (- touchmove or touchcancel ends the touch, no click follows)\n  // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold\n  //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().\n  // - preventGhostClick() removes the allowable region the global touchstart created.\n  // - The browser generates a click event.\n  // - The global click handler catches the click, and checks whether it was in an allowable region.\n  //     - If preventGhostClick was called, the region will have been removed, the click is busted.\n  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and\n  //       other elements without ngTap on them work normally.\n  //\n  // This is an ugly, terrible hack!\n  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users\n  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular\n  // encapsulates this ugly logic away from the user.\n  //\n  // Why not just put click handlers on the element?\n  // We do that too, just to be sure. If the tap event caused the DOM to change,\n  // it is possible another element is now in that position. To take account for these possibly\n  // distinct elements, the handlers are global and care only about coordinates.\n\n  // Checks if the coordinates are close enough to be within the region.\n  function hit(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\n  }\n\n  // Checks a list of allowable regions against a click location.\n  // Returns true if the click should be allowed.\n  // Splices out the allowable region from the list after it has been used.\n  function checkAllowableRegions(touchCoordinates, x, y) {\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\n      if (hit(touchCoordinates[i], touchCoordinates[i+1], x, y)) {\n        touchCoordinates.splice(i, i + 2);\n        return true; // allowable region\n      }\n    }\n    return false; // No allowable region; bust it.\n  }\n\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\n  // was called recently.\n  function onClick(event) {\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\n      return; // Too old.\n    }\n\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\n    // and on the input element). Depending on the exact browser, this second click we don't want\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\n    // click event\n    if (x < 1 && y < 1) {\n      return; // offscreen\n    }\n    if (lastLabelClickCoordinates &&\n        lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\n      return; // input click triggered by label click\n    }\n    // reset label click coordinates on first subsequent click\n    if (lastLabelClickCoordinates) {\n      lastLabelClickCoordinates = null;\n    }\n    // remember label click coordinates to prevent click busting of trigger click event on input\n    if (event.target.tagName.toLowerCase() === 'label') {\n      lastLabelClickCoordinates = [x, y];\n    }\n\n    // Look for an allowable region containing this click.\n    // If we find one, that means it was created by touchstart and not removed by\n    // preventGhostClick, so we don't bust it.\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\n      return;\n    }\n\n    // If we didn't find an allowable region, bust the click.\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Blur focused form elements\n    event.target && event.target.blur();\n  }\n\n\n  // Global touchstart handler that creates an allowable region for a click event.\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\n  function onTouchStart(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    touchCoordinates.push(x, y);\n\n    $timeout(function() {\n      // Remove the allowable region.\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\n        if (touchCoordinates[i] == x && touchCoordinates[i+1] == y) {\n          touchCoordinates.splice(i, i + 2);\n          return;\n        }\n      }\n    }, PREVENT_DURATION, false);\n  }\n\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\n  // zone around the touchstart where clicks will get busted.\n  function preventGhostClick(x, y) {\n    if (!touchCoordinates) {\n      $rootElement[0].addEventListener('click', onClick, true);\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\n      touchCoordinates = [];\n    }\n\n    lastPreventedTime = Date.now();\n\n    checkAllowableRegions(touchCoordinates, x, y);\n  }\n\n  // Actual linking function.\n  return function(scope, element, attr) {\n    var clickHandler = $parse(attr.ngClick),\n        tapping = false,\n        tapElement,  // Used to blur the element after a tap.\n        startTime,   // Used to check if the tap was held too long.\n        touchStartX,\n        touchStartY;\n\n    function resetState() {\n      tapping = false;\n      element.removeClass(ACTIVE_CLASS_NAME);\n    }\n\n    element.on('touchstart', function(event) {\n      tapping = true;\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\n      // Hack for Safari, which can target text nodes instead of containers.\n      if(tapElement.nodeType == 3) {\n        tapElement = tapElement.parentNode;\n      }\n\n      element.addClass(ACTIVE_CLASS_NAME);\n\n      startTime = Date.now();\n\n      var touches = event.touches && event.touches.length ? event.touches : [event];\n      var e = touches[0].originalEvent || touches[0];\n      touchStartX = e.clientX;\n      touchStartY = e.clientY;\n    });\n\n    element.on('touchmove', function(event) {\n      resetState();\n    });\n\n    element.on('touchcancel', function(event) {\n      resetState();\n    });\n\n    element.on('touchend', function(event) {\n      var diff = Date.now() - startTime;\n\n      var touches = (event.changedTouches && event.changedTouches.length) ? event.changedTouches :\n          ((event.touches && event.touches.length) ? event.touches : [event]);\n      var e = touches[0].originalEvent || touches[0];\n      var x = e.clientX;\n      var y = e.clientY;\n      var dist = Math.sqrt( Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2) );\n\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\n        preventGhostClick(x, y);\n\n        // Blur the focused element (the button, probably) before firing the callback.\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\n        // I couldn't get anything to work reliably on Android Chrome.\n        if (tapElement) {\n          tapElement.blur();\n        }\n\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\n          element.triggerHandler('click', [event]);\n        }\n      }\n\n      resetState();\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = function(event) { };\n\n    // Actual click handler.\n    // There are three different kinds of clicks, only two of which reach this point.\n    // - On desktop browsers without touch events, their clicks will always come here.\n    // - On mobile browsers, the simulated \"fast\" click will call this.\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\n    // Therefore it's safe to use this directive on both mobile and desktop.\n    element.on('click', function(event, touchend) {\n      scope.$apply(function() {\n        clickHandler(scope, {$event: (touchend || event)});\n      });\n    });\n\n    element.on('mousedown', function(event) {\n      element.addClass(ACTIVE_CLASS_NAME);\n    });\n\n    element.on('mousemove mouseup', function(event) {\n      element.removeClass(ACTIVE_CLASS_NAME);\n    });\n\n  };\n}]);\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngSwipeLeft\n *\n * @description\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\n * A leftward swipe is a quick, right-to-left slide of the finger.\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\n * upon left swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\n/**\n * @ngdoc directive\n * @name ngSwipeRight\n *\n * @description\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\n * A rightward swipe is a quick, left-to-right slide of the finger.\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\n * upon right swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeRightExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nfunction makeSwipeDirective(directiveName, direction, eventName) {\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {\n    // The maximum vertical delta for a swipe should be less than 75px.\n    var MAX_VERTICAL_DISTANCE = 75;\n    // Vertical distance should not be more than a fraction of the horizontal distance.\n    var MAX_VERTICAL_RATIO = 0.3;\n    // At least a 30px lateral motion is necessary for a swipe.\n    var MIN_HORIZONTAL_DISTANCE = 30;\n\n    return function(scope, element, attr) {\n      var swipeHandler = $parse(attr[directiveName]);\n\n      var startCoords, valid;\n\n      function validSwipe(coords) {\n        // Check that it's within the coordinates.\n        // Absolute vertical distance must be within tolerances.\n        // Horizontal distance, we take the current X - the starting X.\n        // This is negative for leftward swipes and positive for rightward swipes.\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\n        // (ie. same direction as the directive wants) will have a positive delta and\n        // illegal ones a negative delta.\n        // Therefore this delta must be positive, and larger than the minimum.\n        if (!startCoords) return false;\n        var deltaY = Math.abs(coords.y - startCoords.y);\n        var deltaX = (coords.x - startCoords.x) * direction;\n        return valid && // Short circuit for already-invalidated swipes.\n            deltaY < MAX_VERTICAL_DISTANCE &&\n            deltaX > 0 &&\n            deltaX > MIN_HORIZONTAL_DISTANCE &&\n            deltaY / deltaX < MAX_VERTICAL_RATIO;\n      }\n\n      $swipe.bind(element, {\n        'start': function(coords, event) {\n          startCoords = coords;\n          valid = true;\n        },\n        'cancel': function(event) {\n          valid = false;\n        },\n        'end': function(coords, event) {\n          if (validSwipe(coords)) {\n            scope.$apply(function() {\n              element.triggerHandler(eventName);\n              swipeHandler(scope, {$event: event});\n            });\n          }\n        }\n      });\n    };\n  }]);\n}\n\n// Left is negative X-coordinate, right is positive.\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\n\n\n\n})(window, window.angular);\n"]}